import React, { useReducer, useCallback } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var getInitialState = function getInitialState(initialValues) {
  return {
    values: _extends({}, initialValues),
    errors: {},
    touched: {},
    isSubmitted: false,
    submitCounter: 0
  };
};

var reducer = function reducer(state, _ref) {
  var _extends2, _extends3;

  var type = _ref.type,
      payload = _ref.payload;

  switch (type) {
    case 'INPUT_CHANGE':
      var inputKey = payload.key,
          inputValue = payload.value;
      return _extends(_extends({}, state), {}, {
        values: _extends(_extends({}, state.values), {}, (_extends2 = {}, _extends2[inputKey] = inputValue, _extends2)),
        touched: _extends(_extends({}, state.touched), {}, (_extends3 = {}, _extends3[inputKey] = true, _extends3))
      });

    case 'VALIDATE_FORM':
      var errors = payload.errors || {};
      return _extends(_extends({}, state), {}, {
        errors: errors
      });

    case 'RESET_FORM':
      return _extends(_extends({}, payload), {}, {
        errors: {}
      });

    case 'SUBMIT_FORM':
      return _extends(_extends({}, state), {}, {
        isSubmitted: true,
        submitCounter: ++state.submitCounter
      });

    case 'CLEAR_FORM':
      return _extends(_extends({}, state), {}, {
        values: _extends({}, payload.values),
        errors: {}
      });

    default:
      return state;
  }
};

var defaultConfig = {
  validate: true,
  validationOnChange: false,
  validateSchema: false
};

var useForm = function useForm(initialValues, config) {
  if (initialValues === void 0) {
    initialValues = {};
  }

  if (config === void 0) {
    config = _extends({}, defaultConfig);
  }

  var initalState = getInitialState(initialValues);

  var _useReducer = useReducer(reducer, initalState),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var _config = config,
      validate = _config.validate,
      validationOnChange = _config.validationOnChange,
      validateSchema = _config.validateSchema;
  React.useEffect(function () {
    var checkForm = function checkForm() {
      try {
        return Promise.resolve(validateForm()).then(function () {});
      } catch (e) {
        return Promise.reject(e);
      }
    };

    if (validationOnChange && state.isSubmitted) {
      checkForm();
    }
  }, [state.values, validationOnChange]);

  var validateForm = function validateForm() {
    try {
      return Promise.resolve(getValidationErrors()).then(function (_ref2) {
        var isValid = _ref2.isValid,
            errors = _ref2.errors;
        dispatch({
          type: 'VALIDATE_FORM',
          payload: {
            errors: errors
          }
        });
        return isValid;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var getValidationErrors = function getValidationErrors() {
    return new Promise(function (resolve, _) {
      if (validateSchema) {
        try {
          var isValid = validateSchema.validateSync(state.values, {
            abortEarly: false
          });
          resolve({
            isValid: isValid,
            errors: {}
          });
        } catch (err) {
          var errors = {};
          err.inner.forEach(function (yupErr) {
            if (errors[yupErr.path]) {
              errors[yupErr.path].push(yupErr.message);
            } else {
              errors[yupErr.path] = [yupErr.message];
            }
          });
          resolve({
            isValid: false,
            errors: errors
          });
        }
      } else {
        resolve({
          isValid: true,
          errors: {}
        });
      }
    });
  };

  var handleChange = useCallback(function (key, value) {
    try {
      dispatch({
        type: 'INPUT_CHANGE',
        payload: {
          key: key,
          value: value
        }
      });
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  });
  var resetForm = useCallback(function () {
    dispatch({
      type: 'RESET_FORM',
      payload: _extends({}, initalState)
    });
  }, [initalState]);
  var clearForm = useCallback(function () {
    var oldValues = _extends({}, state.values);

    var values = Object.keys(oldValues).forEach(function (key) {
      oldValues[key] = "";
    });
    dispatch({
      type: 'CLEAR_FORM',
      payload: _extends({}, values)
    });
  });
  var handleSubmit = useCallback(function (onSubmit) {
    try {
      var _temp2 = function () {
        if (validate) {
          dispatch({
            type: 'SUBMIT_FORM'
          });
          return Promise.resolve(validateForm()).then(function (_validateForm) {
            if (_validateForm) {
              onSubmit();
            }
          });
        } else {
          onSubmit();
        }
      }();

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  });
  return _extends({
    handleChange: handleChange,
    resetForm: resetForm,
    handleSubmit: handleSubmit,
    clearForm: clearForm
  }, state);
};

export default useForm;
//# sourceMappingURL=index.modern.js.map
